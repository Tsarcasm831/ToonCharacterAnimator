
import * as THREE from 'three';
import { Player } from '../player/Player';
import { PlayerUtils } from '../player/PlayerUtils';
import { InputManager } from '../managers/InputManager';
import { SoundManager } from '../managers/SoundManager';
import { ParticleManager } from '../managers/ParticleManager';
import { BuilderManager } from '../builder/BuilderManager';
import { EntityStats, PlayerConfig, PlayerInput, InventoryItem } from '../../types';
import { PlayerDebug } from '../player/PlayerDebug';
import { PlayerCombat } from '../player/PlayerCombat';
import { RenderManager } from './RenderManager';
import { EntityManager } from '../managers/EntityManager';
import { LowLevelCityGuard } from '../entities/npc/friendly/LowLevelCityGuard';
import { Blacksmith } from '../entities/npc/friendly/Blacksmith';
import { Shopkeeper } from '../entities/npc/friendly/Shopkeeper';
import { SceneManager, SceneType } from '../managers/SceneManager';
import { CombatInteractionManager } from '../managers/CombatInteractionManager';
import { CombatSystem } from '../managers/CombatSystem';
import { CameraManager } from '../managers/CameraManager';
import { LevelGenerator } from '../builder/LevelGenerator';

export class Game {
    public renderManager: RenderManager;
    private clock: THREE.Clock;
    
    public player: Player;
    public entityManager: EntityManager;
    public sceneManager: SceneManager;
    public combatManager: CombatInteractionManager;
    public combatSystem: CombatSystem;
    public cameraManager: CameraManager;

    public inputManager: InputManager;
    private soundManager: SoundManager;
    private particleManager: ParticleManager;
    private builderManager: BuilderManager;

    private animationId: number = 0;
    
    private isBuilding: boolean = false;
    private wasBuilderKeyPressed: boolean = false;
    private wasRotateKeyPressed: boolean = false;
    private lastBuildTime: number = 0;
    private buildCooldown: number = 200; // ms cooldown between builds
    private lastSlotSelectTime: number = 0;
    private slotSelectProtection: number = 300; // ms protection after slot select
    private showObstacleHitboxes: boolean = false;
    private wasFirstPersonKeyPressed: boolean = false;
    
    public config: PlayerConfig;

    private _onPointerLockChange: (e: Event) => void;
    private _onMouseMove: (e: MouseEvent) => void;
    private _onMouseDown: (e: MouseEvent) => void;
    private _onMouseUp: (e: MouseEvent) => void;

    onInteractionUpdate?: (text: string | null, progress: number | null) => void;
    onBuilderToggle?: (active: boolean) => void;
    onBiomeUpdate?: (biome: { name: string, color: string }) => void;
    onRotationUpdate?: (rotation: number) => void;
    onToggleWorldMapCallback?: (pos: THREE.Vector3) => void;
    public onDialogueTrigger?: (content: string) => void;
    public onTradeTrigger?: () => void;
    public onShopkeeperTrigger?: () => void;
    public onForgeTrigger?: () => void;
    public onShowCharacterStats?: (stats?: EntityStats, name?: string) => void;
    public onUnitSelect?: (stats?: EntityStats, unit?: any) => void;
    public onBuildingTypeChange?: (type: any) => void;
    public onAttackHit?: (type: string, count: number) => void;
    public onInventoryUpdate?: (items: (InventoryItem | null)[]) => void;
    public onToggleInventoryCallback?: () => void;
    public onToggleBuilderLogCallback?: () => void;
    public onBuildLog?: (message: string) => void;
    public onEnvironmentReady?: () => void;
    public onUpdate?: (dt: number) => void;
    public onEnterTown?: () => void;
    
    // Combat Events
    public onTurnQueueUpdate?: (queue: any[]) => void;
    public onTurnPhaseChange?: (phase: string) => void;
    public onTurnChanged?: (unit: any) => void;

    private hasSpawnedAllAnimals: boolean = false;
    private enterTownTriggered: boolean = false;

    private currentBiomeName: string = '';
    private lastRotationUpdate = 0;
    private lastRotationValue = 0;
    private lastBiomeCheck = 0;
    private readonly rotationUpdateIntervalMs = 100;
    private readonly rotationUpdateEpsilon = 0.01;

    constructor(container: HTMLElement, initialConfig: PlayerConfig, initialManualInput: Partial<PlayerInput>, initialInventory: (InventoryItem | null)[], activeScene: SceneType) {
        this.config = initialConfig;
        this.renderManager = new RenderManager(container);

        this.inputManager = new InputManager();
        this.inputManager.setManualInput(initialManualInput);
        this.soundManager = new SoundManager();
        this.soundManager.setVolume(initialConfig.globalVolume);

        this.particleManager = new ParticleManager(this.renderManager.scene);
        this.builderManager = new BuilderManager(this.renderManager.scene);
        this.builderManager.onBuild = (type, pos, rot) => {
            const msg = `Built ${type} at (${pos.x.toFixed(2)}, ${pos.y.toFixed(2)}, ${pos.z.toFixed(2)}) Rot: ${rot.toFixed(2)}`;
            this.onBuildLog?.(msg);
        };

        this.player = new Player(this.renderManager.scene);
        Object.assign(this.player.config, initialConfig);
        this.player.inventory.setItems(initialInventory);
        
        this.cameraManager = new CameraManager(this.renderManager, this.player);

        this.sceneManager = new SceneManager(
            this.renderManager.scene,
            this.renderManager,
            null as any,
            this.player,
            activeScene
        );

        this.entityManager = new EntityManager(this.renderManager.scene, this.sceneManager.environment, initialConfig);
        this.sceneManager.setEntityManager(this.entityManager);

        this.combatManager = new CombatInteractionManager(this.entityManager, this.renderManager, this.player);
        this.combatManager.onUnitSelect = (stats, unit) => this.onUnitSelect?.(stats, unit);
        this.combatManager.onShowCharacterStats = (stats, name) => this.onShowCharacterStats?.(stats, name);

        this.combatSystem = new CombatSystem();
        this.combatManager.setCombatSystem(this.combatSystem);
        
        this.combatSystem.onCombatLog = (msg, type) => {
            // Forward to UI if needed, or handle logs
            console.log(`[Combat] ${msg}`);
        };

        this.combatSystem.onTurnChanged = (unit) => {
             this.onTurnChanged?.(unit);
             // Also update queue whenever turn changes
             this.onTurnQueueUpdate?.(this.combatSystem.turnManager.getCurrentQueue());
        };
        
        this.combatSystem.turnManager.onPhaseChange = (phase) => {
            this.onTurnPhaseChange?.(phase);
        };
        
        this.combatSystem.turnManager.onQueueUpdate = (queue) => {
            this.onTurnQueueUpdate?.(queue);
        };

        this.sceneManager.switchScene(activeScene, true);
        
        if (activeScene === 'land') {
            PlayerUtils.setUseLandTerrain(true);
            const playerPos = this.player.mesh.position;
            const groundHeight = PlayerUtils.getGroundHeight(playerPos, this.player.config, this.sceneManager.currentEnvironment?.obstacles);
            this.player.mesh.position.y = groundHeight;
        }
        this.sceneManager.onEnvironmentReady = () => this.onEnvironmentReady?.();

        if (activeScene === 'dev') {
            LevelGenerator.buildDevLevel(this.sceneManager.environment);
            this.sceneManager.environment.obstacleManager.onLogPickedUp = () => {
                this.player.addItem('Wood', 8, true);
            };
            this.entityManager.initDevEntities(this.sceneManager.environment, this.config);
        } else if (activeScene === 'town') {
            this.setupTownScene();
        }
        
        requestAnimationFrame(() => {
            if (this.sceneManager.activeScene === 'dev' && this.sceneManager.environment) {
                this.sceneManager.environment.buildAsync().then(() => {
                    this.onEnvironmentReady?.();
                });
            } else {
                // For other scenes, environment is likely already ready or synchronous
                this.onEnvironmentReady?.();
            }
        });

        this.clock = new THREE.Clock();

        this.setupInputHandlers();
        
        this._onPointerLockChange = this.onPointerLockChange.bind(this);
        this._onMouseMove = this.onMouseMove.bind(this);
        this._onMouseDown = this.onMouseDown.bind(this);
        this._onMouseUp = this.onMouseUp.bind(this);
        
        document.addEventListener('pointerlockchange', this._onPointerLockChange);
        window.addEventListener('mousemove', this._onMouseMove);
        window.addEventListener('mousedown', this._onMouseDown);
        window.addEventListener('mouseup', this._onMouseUp);
        window.addEventListener('contextmenu', (e) => this.onContextMenu(e));
        
        this.animate = this.animate.bind(this);
        
        // Expose debug function globally
        (window as any).debugSpawnYeti = () => {
            console.log('[Game] Debug: Spawning yeti at player position');
            if (this.entityManager && this.player) {
                const playerPos = this.player.position.clone();
                this.entityManager.spawnAnimalGroup('yeti', 1, this.sceneManager.environment, playerPos);
                console.log('[Game] Debug: Total yetis:', this.entityManager.yetis.length);
            }
        };
    }

    private setupInputHandlers() {
        this.inputManager.onToggleHitbox = () => this.player.toggleHitbox();
        this.inputManager.onToggleObstacleHitboxes = () => {
            this.showObstacleHitboxes = !this.showObstacleHitboxes;
            
            // 1. Collect environment obstacles
            let debugObjects: THREE.Object3D[] = [];
            const currentEnv = this.sceneManager.currentEnvironment;
            if (currentEnv) debugObjects = [...currentEnv.obstacles];
            
            // 2. Collect NPCs and units
            const entities = this.entityManager.getEntitiesForScene(this.sceneManager.activeScene);
            entities.forEach(entity => {
                if (entity.group) debugObjects.push(entity.group);
            });
            
            if (debugObjects.length > 0) {
                PlayerDebug.updateObstacleHitboxVisuals(debugObjects, this.showObstacleHitboxes);
            }
        };
        
        this.inputManager.onToggleCamera = () => this.cameraManager.toggleCameraFocus();
        this.inputManager.onToggleFirstPerson = () => this.cameraManager.toggleFirstPerson();
        
        this.inputManager.onToggleHands = () => this.player.toggleHandsDebug();
        this.inputManager.onToggleSkeletonMode = () => this.player.toggleSkeletonMode();
        this.inputManager.onToggleBuilder = () => this.toggleBuilder();
        this.inputManager.onToggleGrid = () => this.sceneManager.currentEnvironment?.toggleWorldGrid();
        this.inputManager.onConfirmBuild = () => this.handleConfirmBuild();
        this.inputManager.onToggleWorldMap = () => {
            this.onToggleWorldMapCallback?.(this.player.mesh.position.clone());
        };
    }

    start() { this.animate(); }
    
    stop() {
        cancelAnimationFrame(this.animationId);
        document.removeEventListener('pointerlockchange', this._onPointerLockChange);
        window.removeEventListener('mousemove', this._onMouseMove);
        window.removeEventListener('mousedown', this._onMouseDown);
        window.removeEventListener('mouseup', this._onMouseUp);
        this.renderManager.dispose(); 
        this.inputManager.dispose();
    }

    private onMouseDown(e: MouseEvent) {
        if (this.sceneManager.activeScene === 'combat') {
            this.combatManager.handleMouseDown(e, this.sceneManager.combatEnvironment);
        }
    }

    private onMouseMove(e: MouseEvent) {
        if (this.sceneManager.activeScene === 'combat') {
            this.combatManager.handleMouseMove(e);
        }
        this.cameraManager.handleMouseMove(e);
    }

    private onMouseUp(e: MouseEvent) {
        if (this.sceneManager.activeScene === 'combat') {
            this.combatManager.handleMouseUp(e, this.sceneManager.combatEnvironment);
        }
    }
    
    private onContextMenu(e: MouseEvent) {
        if (this.sceneManager.activeScene === 'combat') {
            e.preventDefault();
            this.combatManager.handleContextMenu(e);
        }
    }

    public toggleGrid(visible: boolean) {
        if (this.sceneManager.combatEnvironment) {
            this.sceneManager.combatEnvironment.toggleGridLabels(visible);
        }
        if (this.sceneManager.currentEnvironment && this.sceneManager.currentEnvironment !== this.sceneManager.combatEnvironment) {
            this.sceneManager.currentEnvironment.toggleWorldGrid(visible);
        }
    }

    private handleTownEntry(input: PlayerInput): boolean {
        if (this.sceneManager.activeScene !== 'singleBiome' || !this.onEnterTown) {
            this.enterTownTriggered = false;
            return false;
        }

        const GRID_SIZE = 1.3333;
        const targetX = (186 + 0.5) * GRID_SIZE;
        const targetZ = (-174 + 0.5) * GRID_SIZE;
        const dx = this.player.mesh.position.x - targetX;
        const dz = this.player.mesh.position.z - targetZ;
        const radius = GRID_SIZE * 1.5;
        const inRange = (dx * dx + dz * dz) <= (radius * radius);

        if (!inRange) {
            this.enterTownTriggered = false;
            return false;
        }

        this.onInteractionUpdate?.('Press E to Enter Town', null);
        if (input.interact && !this.enterTownTriggered) {
            this.enterTownTriggered = true;
            this.onEnterTown();
        }

        return true;
    }

    private combatInitialized: boolean = false;
    
    public setCombatActive(active: boolean) {
        this.combatManager.setCombatActive(active);
        this.inputManager.setCombatState(active);
        
        if (active && this.sceneManager.activeScene === 'combat' && !this.combatInitialized) {
            this.config.isAssassinHostile = true;
            if (this.sceneManager.combatEnvironment) {
                this.sceneManager.combatEnvironment.setCombatStarted(true);
            }
            // Initialize turn-based or tracked combat system
            const enemies = this.entityManager.getEntitiesForScene('combat');
            this.combatSystem.initializeCombat(this.player, [], enemies);
            this.combatInitialized = true;
        } else if (!active) {
            // Reset combat state when deactivating
            this.combatInitialized = false;
            this.combatSystem.reset();
        }
    }

    public endCombatTurn() {
        if (this.combatSystem) {
            this.combatSystem.endTurn();
        }
    }

    public switchScene(sceneName: SceneType, isInit: boolean = false) {
        this.sceneManager.switchScene(sceneName, isInit);
        this.combatManager.clearSelection();
        const isCombatScene = sceneName === 'combat';
        this.combatManager.setCombatActive(isCombatScene);
        this.inputManager.setCombatState(isCombatScene);
        
        if (sceneName === 'town') {
            this.setupTownScene();
        }
    }

    private setupTownScene() {
        const townEnv = this.sceneManager.townEnvironment;
        if (!townEnv) return;
        this.entityManager.initTownEntities(townEnv, this.config);
    }

    spawnAnimal(type: string, count: number) {
        if (this.sceneManager.activeScene === 'dev') {
            this.entityManager.spawnAnimalGroup(type, count, this.sceneManager.environment, this.player.mesh.position);
        }
    }

    spawnLowLevelGuard(x: number, y: number, z: number, rotation: number = 0) {
        const position = new THREE.Vector3(x, y, z);
        const guard = new LowLevelCityGuard(this.renderManager.scene, position, rotation);
        this.entityManager.guard = guard;
        return guard;
    }

    private toggleBuilder() {
        this.isBuilding = !this.isBuilding;
        this.builderManager.setActive(this.isBuilding);
        this.inputManager.setBuilding(this.isBuilding);
        this.onBuilderToggle?.(this.isBuilding);
        if (this.isBuilding && this.cameraManager.isFirstPerson) this.cameraManager.toggleFirstPerson(false);
    }

    setBuildingType(type: any) { this.builderManager.setType(type); }
    
    private handleConfirmBuild() {
        if (!this.isBuilding) return;
        
        const currentTime = Date.now();
        const timeSinceSlotSelect = currentTime - this.lastSlotSelectTime;
        
        // Only allow confirmation if enough time has passed since slot selection
        if (timeSinceSlotSelect >= this.slotSelectProtection && currentTime - this.lastBuildTime >= this.buildCooldown) {
            const currentEnv = this.sceneManager.currentEnvironment;
            if (currentEnv) {
                this.builderManager.build(currentEnv);
                this.lastBuildTime = currentTime;
                if (this.showObstacleHitboxes) {
                    const debugObjects: THREE.Object3D[] = [...currentEnv.obstacles];
                    const entities = this.entityManager.getEntitiesForScene(this.sceneManager.activeScene);
                    entities.forEach(entity => {
                        if (entity.group) debugObjects.push(entity.group);
                    });
                    PlayerDebug.updateObstacleHitboxVisuals(debugObjects, true);
                }
            }
        }
    }
    
    private onPointerLockChange() { 
        if (document.pointerLockElement !== this.renderManager.renderer.domElement && this.cameraManager.isFirstPerson) 
            this.cameraManager.toggleFirstPerson(false); 
    }

    setManualInput(input: Partial<PlayerInput>) { this.inputManager.setManualInput(input); }
    getActiveScene() { return this.sceneManager.activeScene; }
    setConfig(config: PlayerConfig) { this.config = config; Object.assign(this.player.config, config); this.soundManager.setVolume(config.globalVolume); }
    setInventory(items: (InventoryItem | null)[]) { this.player.inventory.setItems(items); }
    setSlotSelectCallback(cb: (index: number) => void) { 
        this.inputManager.onSlotSelect = (index) => {
            if (this.isBuilding) {
                const presets: any[] = ['foundation', 'wall', 'doorway', 'door', 'roof'];
                if (index >= 0 && index < presets.length) {
                    const type = presets[index];
                    this.setBuildingType(type);
                    this.lastSlotSelectTime = Date.now(); // Track when slot was selected
                    this.onBuildingTypeChange?.(type);
                }
            } else {
                cb(index);
            }
        };
    }
    setControlsActive(active: boolean) { this.renderManager.controls.enabled = active; this.inputManager.setBlocked(!active); }
    
    resize() { this.renderManager.resize(); }

    private animate(time: number = 0) {
        this.animationId = requestAnimationFrame(this.animate);
        
        // Use a fixed delta for logic if real delta is too erratic
        let delta = this.clock.getDelta();
        if (delta > 0.1) delta = 0.1; // Cap large spikes
        if (delta <= 0) return;

        const input = this.inputManager.getInput();
        
        // Debug MP
        if (this.sceneManager.activeScene === 'mp' && (input.x !== 0 || input.y !== 0)) {
             // console.log(`[Game] MP Input: x=${input.x}, y=${input.y}, camRot=${cameraRotation}`);
        }

        if (this.sceneManager.activeScene === 'combat') {
             const cameraInput = this.inputManager.getCameraMovementInput();
             this.cameraManager.handleCombatCamera(cameraInput, delta);
             // handleCombatCamera consumes input for movement, so we don't need to manually reset it here if the manager does it.
             // However, checking the manager code, it resets input.x/y/isRunning.
             input.attack1 = false;
             input.attack2 = false;
        }

        const joyLook = this.inputManager.getJoystickLook();
        this.cameraManager.handleJoystickLook(joyLook, delta);

        if (input.toggleFirstPerson && !this.wasFirstPersonKeyPressed) this.cameraManager.toggleFirstPerson();
        this.wasFirstPersonKeyPressed = !!input.toggleFirstPerson;
        
        if (input.rotateGhost && !this.wasRotateKeyPressed) this.builderManager.rotate();
        this.wasRotateKeyPressed = !!input.rotateGhost;

        // 1. Get Camera Rotation (for input relative movement)
        const cameraRotation = this.cameraManager.getCameraRotation();

        this.sceneManager.update(delta, this.config);
        
        const currentEnv = this.sceneManager.currentEnvironment;
        const currentEntities = this.entityManager.getEntitiesForScene(this.sceneManager.activeScene);
        
        this.entityManager.update(
            delta, 
            this.config, 
            this.player.mesh.position,
            this.renderManager.camera.position,
            currentEnv, 
            this.sceneManager.activeScene, 
            this.combatManager.isActive,
            this.onAttackHit,
            currentEntities
        );

        // Update Auto-Battler System
        if (this.combatManager.isActive && this.sceneManager.activeScene === 'combat') {
            if (this.sceneManager.combatEnvironment) {
                this.combatSystem.update(delta, this.sceneManager.combatEnvironment);
            }
        }

        this.particleManager.update(delta);
        
        if (currentEnv) {
            if (time - this.lastBiomeCheck > 500) {
                this.lastBiomeCheck = time;
                if ((currentEnv as any).getBiomeAt) {
                    const biome = (currentEnv as any).getBiomeAt(this.player.mesh.position);
                    if (biome.name !== this.currentBiomeName) { this.currentBiomeName = biome.name; this.onBiomeUpdate?.(biome); }
                }
            }
            
            const playerInput = { ...input };
            if (this.isBuilding) { playerInput.attack1 = false; playerInput.attack2 = false; }
            
            PlayerCombat.updateProjectiles(delta, currentEnv, this.particleManager, currentEntities);
            
            this.player.update(delta, playerInput, this.renderManager.camera.position, cameraRotation, currentEnv, this.particleManager, currentEntities, this.combatManager.isActive);
            
            // Check if player is in arena and adjust ground height if needed
            if (this.sceneManager.activeScene === 'town' && this.sceneManager.townEnvironment) {
                const townEnv = this.sceneManager.townEnvironment;
                if (townEnv.isPositionInArena(this.player.mesh.position)) {
                    const arenaGroundHeight = townEnv.getGroundHeightAt(this.player.mesh.position);
                    // Only adjust if player is at or below arena floor level
                    if (this.player.mesh.position.y <= arenaGroundHeight + 0.5) {
                        this.player.mesh.position.y = arenaGroundHeight;
                    }
                }
            }
            
            if (this.player.mesh && this.player.model?.group) {
                this.player.model.group.position.copy(this.player.mesh.position);
                this.player.model.group.rotation.copy(this.player.mesh.rotation);
            }
            if (this.isBuilding && this.inputManager.mousePosition && (this.sceneManager.activeScene === 'dev' || this.sceneManager.activeScene === 'singleBiome' || this.sceneManager.activeScene === 'land')) {
                this.builderManager.update(this.player.mesh.position, this.player.mesh.rotation.y, currentEnv as any, this.renderManager.camera, this.inputManager.mousePosition);
            }
        }

        // 2. Update Camera Position (AFTER player has moved to prevent jitter)
        this.cameraManager.updatePosition(this.sceneManager.activeScene);

        this.soundManager.update(this.player, delta, currentEnv);
        
        if (time - this.lastRotationUpdate >= this.rotationUpdateIntervalMs || Math.abs(cameraRotation - this.lastRotationValue) >= this.rotationUpdateEpsilon) {
            this.lastRotationUpdate = time; this.lastRotationValue = cameraRotation;
            this.onRotationUpdate?.(cameraRotation);
        }

        if (this.player.isTalking) this.onInteractionUpdate?.(null, null);
        else if (this.player.isSkinning) this.onInteractionUpdate?.(null, this.player.skinningProgress);
        else if (this.player.combat.isChargingFishing) this.onInteractionUpdate?.('Power', this.player.combat.fishingCharge);
        else if (this.handleTownEntry(input)) {
            // handled by town-entry prompt
        } else if (this.player.canTalk) {
            const target = this.player.talkingTarget;
            const targetName = target?.constructor.name;
            
            const label = (targetName === 'Shopkeeper' || target instanceof Shopkeeper)
                ? 'Press E to Chat'
                : (targetName === 'Blacksmith' || target instanceof Blacksmith)
                    ? 'Press E to Trade'
                    : 'Press E to Talk';
            
            this.onInteractionUpdate?.(label, null);
            if (input.interact) { 
                this.player.isTalking = true; 
                if (targetName === 'LowLevelCityGuard' || target instanceof LowLevelCityGuard) { 
                    target.isLeftHandWaving = true; 
                    target.leftHandWaveTimer = 0; 
                    this.onDialogueTrigger?.("Greetings, traveler. Keep your weapons sheathed within city limits and we'll have no trouble. The roads are dangerous these days, stay vigilant."); 
                } 
                else if (targetName === 'Blacksmith' || target instanceof Blacksmith) this.onTradeTrigger?.();
                else if (targetName === 'Shopkeeper' || target instanceof Shopkeeper) this.onShopkeeperTrigger?.();
                else this.onDialogueTrigger?.("Greetings, traveler.");
            }
        } else if (this.player.canSkin) this.onInteractionUpdate?.('Press F to Skin', null);
        else {
            const target = this.player.interactableTarget;
            if (target) {
                const label = target.userData.interactType === 'forge' ? 'Press E to Forge' : 'Interact';
                this.onInteractionUpdate?.(label, null);
                if (input.interact && target.userData.interactType === 'forge') this.onForgeTrigger?.();
            } else this.onInteractionUpdate?.(null, null);
        }
        if (this.player.inventory.isDirty) { this.onInventoryUpdate?.([...this.player.inventory.items]); this.player.inventory.isDirty = false; }
        this.renderManager.render();
        this.onUpdate?.(delta);
    }
}
